# VeHa 2025

---

#### Pleshcheyevo ozero surf club
##### Пирко В.В., Зайковская Е.В., Старовойтов А.И.

---

Задание 2 - Разработка спецификации распределенной системы контроля версий на TLA+.

Задание было выполнено полностью, соответствие модели заданным инвариантам проверено TLC.

В ходе выполнения заданий стоит отметить некоторые моменты в решении: решение последнего задания несколько изменяет процесс записи в файл.

Что касается вопроса записи в файл - в комментарии к спецификации предлагается реализовать запись в файл следующим образом:
- NewFile возвращает новое значение для всего файла, при этом модифицируя
только строку, на указывает параметр line_num.
- За одну запись затрагивается только файл одного конкретного пользователя,
остальные файлы остаются неизменными.
- Новое значение вычисляется на основе старого результатом применения
следующей арифметической операции: нужно взять значение, записанноев строке, умножить его на номер строки и умножить на ID пользователя.

Далее показано, что при таком способе записи в файл нарушится инвариант `DiffBetweenConsequentEntries`.
В рассуждениях ниже я опущу идентификатор пользователя в логах (в модели он, конечно, присутствует).
В предложенном шаблоне реализации merge возможна ситуация, когда в логе сливающего пользователя будут дублироваться последние две записи файла:
user1 делает изменения:
```
<1, 1> -> <1, 2> -> <1, 4>
```
и отправляет их на сервер, файл лога которого до отправки выглядит так:
```
< <1, 1> >
```
user2 делает изменение:
```
<1, 1> -> <1, 4>
```

Теперь, при попытке слияния user2 произойдет следующее:
- `DivergentIndex = 2`
- `ChangedEntries = <[line_num |-> 2, value |-> 4]>`
- Базовым логом предлагается выбрать лог сервера, в момент попытки слияния после push'а user1 лог сервера выглядит так: 
```
< <1, 1>, <1, 2>, <1, 4> >
```

Но тогда после выполнения действия merge, которое задано так:
```
Merge(user) ==
    /\ user \in USERS
    /\ AbleToMergeButNotPullOrPush(user)
    /\ log' = [
        log EXCEPT ![user] = ApplyDivergence(
            user,
            log[SERVER],
            ChangedEntries(user))]
    /\ file' = [file EXCEPT ![user] = log'[user][Len(log[user])].file]
```
`ApplyDivergence` попытается применить идемпотентное с точки зрения данных изменение `<[line_num |-> 2, value |-> 4]>`. Лог итак в последнем файле 
во второй строке содержит 4. Получаются две записи в логе с одинаковым файлом, отличающиеся лишь id пользователя.

Это вполне корректное поведение, но в таком случае невыполним инвариант DiffBetweenConsequentEntries, требующий, чтобы в соседних файлах лога (id пользователя данный инвариант не учитывает) существовала одна и только одна отличающаяся строка.

Для разрешени конфликта было принято решение изменить процесс записи. Теперь при изменении строки номер строки и номер пользователя "хэшируется" с помощью простых чисел:
```
\* Было:
NewFile(user, line_num) ==
    [file EXCEPT ![user][line_num] = @ * user * line_num]
```
```
\* Стало:
PRIMES = <<2, 3, ..., 107>>

UserId(u) ==
    PRIMES[u]

LineId(i) ==
    PRIMES[MAX_USERS + 1 + i]

NewFile(user, line_num) ==
    [file EXCEPT ![user][line_num] = @ * UserId(user) * LineId(line_num)]
```
Такая стратегия записи гарантирует, что никакие два пользователя не смогут прийти к одному и тому же файлу разными способами.

Было добалвено одно safety-свойство:
```
NoDirectChangesOnServer ==
    /\ ~Modified(SERVER)
```
Оно гарантирует, что сервер самовольно не изменит свой файл.

Еще была добавлена пара темпоральных свойств:
```
\** Лог ограничен -> когда-то нельзя будет совершать коммиты
EventuallyUnableToCommit == 
    \A u \in USERS: <>[] ~(ENABLED Commit(u))

\** Сильная версия LogAlwaysGrows
LogReachesMaxLength ==
    \E n \in MAX_LOG_SIZE..GLOBAL_MAX_LOG_SIZE:
        \A u \in USERS: <>[](Len(log[u]) = n)
```

##### N.B.

Все комментарии в решениях, начинающиеся с `\**` - наши.

---

При выполнении задания использовались ресурсы:
- https://learntla.com/reference/standard-library.html
- https://lamport.azurewebsites.net/video/videos.html
- методичка (материалы VeHa)

---

Финальная версия задания представлена в файлах solution.*

Проверка модели с параметрами
```
MAX_TEXT_LINES = 3
MAX_USERS = 2
MAX_LOG_SIZE = 3
```
и параметрами запуска `-workers 8 - coverage 1`
заняла около минуты и 10 секунд на процессоре 11th Gen Intel(R) Core(TM) i5-11300H @ 3.10GHz с 8-ю ядрами.

Возможно, добавленные темпоральные свойства стоило заменить на аналогичные по смыслу инварианты с помощью `~(ENABLED Next) -> ...`. Это ускоряет время работы TLC.