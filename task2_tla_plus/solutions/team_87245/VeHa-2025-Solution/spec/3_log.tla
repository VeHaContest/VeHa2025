----MODULE 3_log----
EXTENDS Naturals, Sequences

(*    ОПИСАНИЕ СПЕЦИФИКАЦИИ №3    *)

(* В этой спецификации мы добавляем логи записей в файл.
   Теперь пользователи не только пишут в файлы, но и делают
   соответствующие записи в лог. У каждого пользователя имеется
   свой собственный локальный лог.

   Логи потребуются в последующих спецификациях для отслеживания
   истории изменений файлов для их синхронизации между пользователями.

   Из спецификации убраны конечное состояние Success и константа ANSWER:
   они были нужны только для проверки корректности записи в файл.
   Добавлены ряд вспомогательных операторов, а также инварианты и
   темпоральные свойства.

   В задании нужно сделать следующее:
   1) Вставить части оператора NewFile и действия Write, реализованные в
      предыдущей спецификации
   2) По тексту спецификации разобраться в структуре лога и реализовать
      тело действия Commit.
   3) ОПЦИОНАЛЬНО: Если у вас получилось придумать дополнительный инвариант,
      которой задавал мы условия корректности для логов и которой еще не
      выражен в имеющихся инвариантах, то вы можете добавить его в конец файла.
      Не забудьте указать его в конфигурации запуска TLC в соседнем .cfg файле,
      иначе вы не сможете проверить его выполнимость.

   Commit должен удовлетворять следующим требованиям:
   - результат выполнения действия это добавление в лог текущего
     состояния файла
   - добавление в лог возможно только в случае, если содержимое файла
     изменено
   - размер лога ограничен (см. константы спецификации), если он заполнен,
     то добавление новой записи должно быть невозможно. Заметка: данное
     свойство добавлено в целях оптимизации, без него пространство состояний
     спецификации бесконечно. Если запуск TLC у вас не завершается, то
     вы не реализовали корректно данное условие.

   Проверить корректность спецификации запуском TLC. Если все в порядке,
   переходить к следующему заданию. Иначе нужно разобраться, какое из
   сформулированных в спецификации условий нарушается и как это можно
   исправить.

   Модифицировать текст спецификации можно только в местах, которые
   помечены текстом "INSERT YOU CODE HERE". Вносить изменения в прочие части
   можно только в случае, если вы нашли в приведенном коде ошибку.
 *)

CONSTANTS
    MAX_TEXT_LINES,
    MAX_USERS,
    \* Максимальный размер лога пользователя
    MAX_LOG_SIZE

VARIABLES
    \* файлы пользователей
    file,
    \* логи пользователей
    log

TEXT_LINES == 1..MAX_TEXT_LINES
INIT_VALUE == 1
USERS == 1..MAX_USERS

NewFile(user, line_num) ==
    
    [file EXCEPT ![user] = [@ EXCEPT ![line_num] = @ * line_num]]


\* получить последнюю запись из лога пользователя
LastLogEntry(user) ==
    log[user][Len(log[user])]

\* признак того, что файл был изменён, а изменения пока не нашли
\* отражения в логе
Modified(user) ==
    LastLogEntry(user).file /= file[user]

Write(user, line_num) ==
    /\ user \in USERS
    /\ line_num \in TEXT_LINES
    
    /\ file' = NewFile(user, line_num)

    \* Ограничиваем возможность бесконечно делать write:
    \* если файл уже изменен, то мы можем только закоммитить изменение
    /\ Modified(user) = FALSE
    /\ UNCHANGED <<log>>

\* Тут создаём новую запись для лога
NewLogEntry(user) ==
    [user |-> user, file |-> file[user]]

\* Commit - операция, которая отражает последние изменения файла пользователя
\* в логе, упрощённая имитация git commit (без stage area и пр).
\* После Commit мы считаем, что новых изменений в файле нет, то есть
\* Modified(user) должно возвращать FALSE
Commit(user) ==
    
    /\ user \in USERS
    /\ Modified(user) = TRUE
    /\ Len(log[user]) < MAX_LOG_SIZE
    /\ log' = [log EXCEPT ![user] = Append(log[user], NewLogEntry(user))]
    /\ UNCHANGED <<file>>


WriteAction ==
    \E user \in USERS, line_num \in TEXT_LINES:
        /\ Write(user, line_num)

CommitAction ==
    \E user \in USERS:
        Commit(user)

InitFile == [l \in TEXT_LINES |-> INIT_VALUE]
InitLog(u) == <<[user |-> u, file |-> InitFile]>>

Init ==
    /\ file = [u \in USERS |-> InitFile]
    /\ log  = [u \in USERS |-> InitLog(u)]

\* Либо какой-то пользователь что-то пишет в файл,
\* либо добавляет в лог запись об изменениях в файле.
Next ==
    \/ WriteAction
    \/ CommitAction

\* для удобства написания дальнейших определений,
\* создадим определение vars, которое будет
\* соответствовать содержимому всех переменных спецификации
vars == <<file, log>>

\* Определение Spec содержит полную спецификацию:
\* Init - множество начальных состояний
\* Next - шаг перехода между состояниями
\* WF - weak fairness - специальное указание модел-чекеру,
\*      чтобы при анализе темпоральных свойств
\*      он не рассматривал пути, где только один пользователь
\*      что-то делает, а все остальные ничего не делают.
\*      Weak/Strong fairness говорит о том, что если в
\*      системе какой-то пользователь может сделать действие,
\*      то он обязательно его когда-нибудь сделает и не будет
\*      вырожденных ситуаций, когда активен всё время
\*      только один пользователь.
Spec ==
    /\ Init
    /\ [][Next]_vars \* эквивалентно [][Next]_<<file, log>>
    /\ WF_vars(Next) \* WF_<<file, log>>(Next)

FileType == [TEXT_LINES -> Nat]

\* тип записи в логе - множество всех возможных записей:
\* user - пользователь, который внёс данные изменения
\* file - содержимое файла с изменениями пользователя
LogEntryType == [user: USERS, file: FileType]

TypeOK ==
    /\ file \in [USERS -> FileType]
    \* Следующие три формулы задают тип переменной log:
    \* для каждого пользователя это sequence записей вида LogEntryType.
    /\ DOMAIN log = USERS
    /\ \A u \in USERS: \A i \in DOMAIN log[u]: i >= 1
    /\ \A u \in USERS: \A i \in DOMAIN log[u]: log[u][i] \in LogEntryType

\* Количество записей в логе ограничено некоторой константой и не может
\* быть превышено.
LogIsBounded ==
    \A u \in USERS: Len(log[u]) <= MAX_LOG_SIZE

\* Если изменения в файле были добавлены в лог, то последняя запись лога
\* соответствует новому содержимому файла.
LastLogEntryIsFile ==
    \A u \in USERS: Modified(u) = FALSE => LastLogEntry(u).file = file[u]

\* Мы не можем повторно перезаписывать содержимое файла, если до этого не
\* добавили предыдущие изменения в лог.
WriteOnlyOnce ==
    \A u \in USERS: \E line_num \in TEXT_LINES:
        ENABLED Write(u, line_num) => ~(ENABLED Commit(u))

\* При штатном функционировании системы (см. fairness в документации TLA+)
\* мы всегда дойдем до момента, когда лог будет полностью заполнен.
LogAlwaysGrows ==
    \A u \in USERS: <>(Len(log[u]) = MAX_LOG_SIZE)

\* Каждая запись в логе пользователя отражает изменение в одной и только одной
\* строке файла. Не должно быть ситуации, когда любые две соседние записи
\* в логе отличались больше чем на одну строку.
DiffBetweenConsequentEntries ==
    \A u \in USERS: \A i \in DOMAIN log[u]: i + 1 \in DOMAIN log[u] =>
        \E line_num \in TEXT_LINES:
            /\ log[u][i].file[line_num] /= log[u][i + 1].file[line_num]
            /\ \A other_line_num \in TEXT_LINES: other_line_num /= line_num =>
                    log[u][i].file[other_line_num] = log[u][i + 1].file[other_line_num]


\* нет дополнительных инвариантов

====